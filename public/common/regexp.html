<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link href="resources/favicon.ico" rel="icon" type="image/x-icon">
    <link href="../../resources/css/style.css" rel="stylesheet">

    
<link ref="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css" />
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script src="http://yandex.st/highlightjs/8.0/languages/clojure.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body>
    <h1>Under Construction</h1>

    
<div class="example-header">
  <h2><a href="./">common</a></h2>
  <h3><a href="https://github.com/netpyoung/clojure-by-example/blob/gh-pages/examples/src/common/regexp.clj">src</a></h3>
  <h3><a href="https://raw.githubusercontent.com/netpyoung/clojure-by-example/gh-pages/examples/src/common/regexp.clj">raw</a></h3>
</div>

<div class="example">
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">(ns common.regexp)</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;https://github.com/clojure-cookbook/clojure-cookbook/blob/master/01_primitive-data/1-08_matching-strings.asciidoc&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">(re-find #&amp;quot;p([a-z]+)ch&amp;quot;, &amp;quot;peach&amp;quot;)</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">;; =&amp;gt; [&amp;quot;peach&amp;quot; &amp;quot;ea&amp;quot;]</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// This tests whether a pattern matches a string.
&lt;br  /&gt;match, _ := regexp.MatchString(&amp;ldquo;p([a-z]+)ch&amp;rdquo;, &amp;ldquo;peach&amp;rdquo;)
&lt;br  /&gt;fmt.Println(match)&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// Above we used a string pattern directly, but for
&lt;br  /&gt;// other regexp tasks you&#39;ll need to &lt;code&gt;Compile&lt;/code&gt; an
&lt;br  /&gt;// optimized &lt;code&gt;Regexp&lt;/code&gt; struct.&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">(def r (re-pattern &amp;quot;p([a-z]+)ch&amp;quot;))
(re-find r &amp;quot;peach&amp;quot;)</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">;; =&amp;gt; [&amp;quot;peach&amp;quot; &amp;quot;ea&amp;quot;]</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">(require &#39;[clojure.string :as s])
(re-seq r &amp;quot;peach punch&amp;quot;)</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        
      </td>

      <td class="code">
        <pre><code class="clojure">;; =&amp;gt; ([&amp;quot;peach&amp;quot; &amp;quot;ea&amp;quot;] [&amp;quot;punch&amp;quot; &amp;quot;un&amp;quot;])</code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// The also finds the first match but returns the
&lt;br  /&gt;// start and end indexes for the match instead of the
&lt;br  /&gt;// matching text.
&lt;br  /&gt;fmt.Println(r.FindStringIndex(&amp;ldquo;peach punch&amp;rdquo;))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// The &lt;code&gt;Submatch&lt;/code&gt; variants include information about
&lt;br  /&gt;// both the whole-pattern matches and the submatches
&lt;br  /&gt;// within those matches. For example this will return
&lt;br  /&gt;// information for both &lt;code&gt;p([a-z]+)ch&lt;/code&gt; and &lt;code&gt;([a-z]+)&lt;/code&gt;.
&lt;br  /&gt;fmt.Println(r.FindStringSubmatch(&amp;ldquo;peach punch&amp;rdquo;))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// Similarly this will return information about the
&lt;br  /&gt;// indexes of matches and submatches.
&lt;br  /&gt;fmt.Println(r.FindStringSubmatchIndex(&amp;ldquo;peach punch&amp;rdquo;))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// The &lt;code&gt;All&lt;/code&gt; variants of these functions apply to all
&lt;br  /&gt;// matches in the input, not just the first. For
&lt;br  /&gt;// example to find all matches for a regexp.
&lt;br  /&gt;fmt.Println(r.FindAllString(&amp;ldquo;peach punch pinch&amp;rdquo;, -1))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// These &lt;code&gt;All&lt;/code&gt; variants are available for the other
&lt;br  /&gt;// functions we saw above as well.
&lt;br  /&gt;fmt.Println(r.FindAllStringSubmatchIndex(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   &quot;peach punch pinch&quot;, -1))
&lt;/code&gt;&lt;/pre&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// Providing a non-negative integer as the second
&lt;br  /&gt;// argument to these functions will limit the number
&lt;br  /&gt;// of matches.
&lt;br  /&gt;fmt.Println(r.FindAllString(&amp;ldquo;peach punch pinch&amp;rdquo;, 2))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// Our examples above had string arguments and used
&lt;br  /&gt;// names like &lt;code&gt;MatchString&lt;/code&gt;. We can also provide
&lt;br  /&gt;// &lt;code&gt;[]byte&lt;/code&gt; arguments and drop &lt;code&gt;String&lt;/code&gt; from the
&lt;br  /&gt;// function name.
&lt;br  /&gt;fmt.Println(r.Match([]byte(&amp;ldquo;peach&amp;rdquo;)))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// When creating constants with regular expressions
&lt;br  /&gt;// you can use the &lt;code&gt;MustCompile&lt;/code&gt; variation of
&lt;br  /&gt;// &lt;code&gt;Compile&lt;/code&gt;. A plain &lt;code&gt;Compile&lt;/code&gt; won&#39;t work for
&lt;br  /&gt;// constants because it has 2 return values.
&lt;br  /&gt;r = regexp.MustCompile(&amp;ldquo;p([a-z]+)ch&amp;rdquo;)
&lt;br  /&gt;fmt.Println(r)&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// The &lt;code&gt;regexp&lt;/code&gt; package can also be used to replace
&lt;br  /&gt;// subsets of strings with other values.
&lt;br  /&gt;fmt.Println(r.ReplaceAllString(&amp;ldquo;a peach&amp;rdquo;, &amp;ldquo;&lt;fruit&gt;&amp;ldquo;))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs">
        &lt;p&gt;// The &lt;code&gt;Func&lt;/code&gt; variant allows you to transform matched
&lt;br  /&gt;// text with a given function.
&lt;br  /&gt;in := []byte(&amp;ldquo;a peach&amp;rdquo;)
&lt;br  /&gt;out := r.ReplaceAllFunc(in, bytes.ToUpper)
&lt;br  /&gt;fmt.Println(string(out))&lt;/p&gt;

      </td>

      <td class="code">
        <pre><code class="clojure"></code></pre>
      </td>
    </tr>
  </table>
  
</div>

  </body>

</html>
