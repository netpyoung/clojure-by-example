<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link href="resources/favicon.ico" rel="icon" type="image/x-icon">
    <link href="../../resources/css/style.css" rel="stylesheet">
    
<link ref="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css" />
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script src="http://yandex.st/highlightjs/8.0/languages/clojure.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body>
    <h1>Under Construction</h1>
    
<div class="example-header">
  <h2><a href="./">common</a></h2>
  <h3><a href="https://github.com/netpyoung/clojure-by-example/blob/gh-pages/examples/src/common/regexp.clj">src</a></h3>
  <h3><a href="https://raw.githubusercontent.com/netpyoung/clojure-by-example/gh-pages/examples/src/common/regexp.clj">raw</a></h3>
</div>

<div class="example">
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">(ns common.regexp)</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>https://github.com/clojure-cookbook/clojure-cookbook/blob/master/01_primitive-data/1-08_matching-strings.asciidoc</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">(re-find #&quot;p([a-z]+)ch&quot;, &quot;peach&quot;)</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">;; =&gt; [&quot;peach&quot; &quot;ea&quot;]</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// This tests whether a pattern matches a string.
<br  />match, _ := regexp.MatchString(&ldquo;p([a-z]+)ch&rdquo;, &ldquo;peach&rdquo;)
<br  />fmt.Println(match)</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// Above we used a string pattern directly, but for
<br  />// other regexp tasks you'll need to <code>Compile</code> an
<br  />// optimized <code>Regexp</code> struct.</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">(def r (re-pattern &quot;p([a-z]+)ch&quot;))
(re-find r &quot;peach&quot;)</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">;; =&gt; [&quot;peach&quot; &quot;ea&quot;]</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">(require '[clojure.string :as s])
(re-seq r &quot;peach punch&quot;)</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"></td>
      <td class="code"><pre><code class="clojure">;; =&gt; ([&quot;peach&quot; &quot;ea&quot;] [&quot;punch&quot; &quot;un&quot;])</code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// The also finds the first match but returns the
<br  />// start and end indexes for the match instead of the
<br  />// matching text.
<br  />fmt.Println(r.FindStringIndex(&ldquo;peach punch&rdquo;))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// The <code>Submatch</code> variants include information about
<br  />// both the whole-pattern matches and the submatches
<br  />// within those matches. For example this will return
<br  />// information for both <code>p([a-z]+)ch</code> and <code>([a-z]+)</code>.
<br  />fmt.Println(r.FindStringSubmatch(&ldquo;peach punch&rdquo;))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// Similarly this will return information about the
<br  />// indexes of matches and submatches.
<br  />fmt.Println(r.FindStringSubmatchIndex(&ldquo;peach punch&rdquo;))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// The <code>All</code> variants of these functions apply to all
<br  />// matches in the input, not just the first. For
<br  />// example to find all matches for a regexp.
<br  />fmt.Println(r.FindAllString(&ldquo;peach punch pinch&rdquo;, -1))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// These <code>All</code> variants are available for the other
<br  />// functions we saw above as well.
<br  />fmt.Println(r.FindAllStringSubmatchIndex(</p>
<pre><code>   "peach punch pinch", -1))
</code></pre>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// Providing a non-negative integer as the second
<br  />// argument to these functions will limit the number
<br  />// of matches.
<br  />fmt.Println(r.FindAllString(&ldquo;peach punch pinch&rdquo;, 2))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// Our examples above had string arguments and used
<br  />// names like <code>MatchString</code>. We can also provide
<br  />// <code>[]byte</code> arguments and drop <code>String</code> from the
<br  />// function name.
<br  />fmt.Println(r.Match([]byte(&ldquo;peach&rdquo;)))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// When creating constants with regular expressions
<br  />// you can use the <code>MustCompile</code> variation of
<br  />// <code>Compile</code>. A plain <code>Compile</code> won't work for
<br  />// constants because it has 2 return values.
<br  />r = regexp.MustCompile(&ldquo;p([a-z]+)ch&rdquo;)
<br  />fmt.Println(r)</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// The <code>regexp</code> package can also be used to replace
<br  />// subsets of strings with other values.
<br  />fmt.Println(r.ReplaceAllString(&ldquo;a peach&rdquo;, &ldquo;<fruit>&ldquo;))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
  <table>
    <tr>
      <td class="docs"><p>// The <code>Func</code> variant allows you to transform matched
<br  />// text with a given function.
<br  />in := []byte(&ldquo;a peach&rdquo;)
<br  />out := r.ReplaceAllFunc(in, bytes.ToUpper)
<br  />fmt.Println(string(out))</p>
</td>
      <td class="code"><pre><code class="clojure"></code></pre></td>
    </tr>
  </table>
  
</div>

  </body>

</html>
